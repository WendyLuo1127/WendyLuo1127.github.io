[{"title":"C++中的字符串转数组","url":"/2025/06/04/C-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E7%BB%84/","content":"Input:   \n[[1,2,3][11,12,13]]\nbelike\nA = 1  2  3    11 12 13\n\n1. istringstream#include&lt;sstream&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; result;string line = input;string current;// 去掉最外层括号for (auto &amp;c : line) &#123;    if (c == &#x27;[&#x27; || c == &#x27;]&#x27;)        current += c; // 保留括号来分隔    else if (c == &#x27;,&#x27;)        current += &#x27; &#x27;; // 用空格替换逗号    else        current += c;&#125;istringstream iss(current);string token;while (iss &gt;&gt; token) &#123;    if (token[0] == &#x27;[&#x27;) &#123;        vector&lt;int&gt; row;        while (iss &gt;&gt; token &amp;&amp; token[0] != &#x27;]&#x27;) &#123;            row.push_back(stoi(token));        &#125;        result.push_back(row);    &#125;&#125;\n2. auto i:line#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;string line;getline(cin,line);vector&lt;vector&lt;int&gt;&gt;nums;vector&lt;int&gt;row;int num=0;for(auto i:line)&#123;    if(isdigit(i))&#123;        num=num*10+i;    &#125;    else &#123;        row.push_back(num);        num=0;        if(i==&#x27;]&#x27;)&#123;            nums.push_back(row);            row.clean();        &#125;    &#125;&#125;","categories":["grammar"],"tags":["computer","C/C++"]},{"title":"NO.38_CCF-CSP","url":"/2025/06/08/NO-38-CCF-CSP/","content":"记录一下2025年6月8号下午13：30-17：30奋战CCF-CSP四小时无果后，“第一次考试就280+”的黄粱美梦无情破碎的故事。多少分就不说了，只能说还是太嫩了。题目列表\n\n正态分布\n马走“日”的可能数\n解码\n月票的可能数\n旅行攻略\n\n\n正态分布题目描述已知一个正态分布 \\( X \\sim N(\\mu, \\sigma^2) \\)，以及一个观测值 \\( n \\)，请将其转换为标准正态分布下的 z 值，并判断该 z 值在标准正态分布表中所对应的 行号和列号：\n\n行号：取 z 值保留一位小数后的值乘以 10（例如 z &#x3D; 1.23 ⇒ 行号为 12）\n列号：取 z 值保留两位小数后的第二位小数（例如 z &#x3D; 1.23 ⇒ 列号为 3）\n\n注意：标准正态分布表通常只列出 z ≥ 0 的部分，若 z &lt; 0，应提示不在查表范围内。\n输入格式第一行输入一个整数 \\( t \\)（表示测试数据组数）接下来每组测试输入三项：\n\n\\( \\mu \\)：正态分布的均值（double）\n\\( \\sigma \\)：标准差（double，非零正数）\n\\( n \\)：观测值（double）\n\n输出格式对于每组测试，输出对应的行号和列号。\n输入样例2100 15 124.550 5 45.3\n输出样例16 3\n\n提示\n可使用公式 ( z &#x3D; \\frac{n - \\mu}{\\sigma} ) 进行标准化；\n行号取整数部分 z × 10，列号取 z 保留两位小数后的小数点第二位；\n若 z 值近似边界（如 z &#x3D; 1.23999），建议用四舍五入防止误差。\n\n代码#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;int main() &#123;    int t;    cin &gt;&gt; t;    while (t--) &#123;        double mu, sigma, n;        cin &gt;&gt; mu &gt;&gt; sigma &gt;&gt; n;        double z = (n - mu) / sigma;        cout &lt;&lt; fixed &lt;&lt; setprecision(4);                  int row = int(z * 10);        int col = int(z * 100 + 0.5) % 10;        cout &lt;&lt; row &lt;&lt; &quot;  &quot; &lt;&lt; col &lt;&lt; endl;    &#125;    return 0;&#125;\n注意:总共只有10列\n马走“日”的可能数题目描述在一个 ( n \\times n ) 的国际象棋棋盘上，给定马的初始位置 ( (x, y) ) 和最多可走的步数 ( k )。请计算在不走出棋盘的前提下，马从起始位置最多走 ( k ) 步，可以到达多少个不同的位置（包括起点）。\n马的移动方式如下（共 8 种）：\n\n(±2, ±1)\n(±1, ±2)\n\n输入格式第一行输入一个整数 ( t )（表示测试组数）接下来每组输入四个整数：\n\n( n )：棋盘大小（1 ≤ n ≤ 25）\n( x )、( y )：起始位置，坐标从 0 开始（0 ≤ x, y &lt; n）\n( k )：最多可以移动的步数（0 ≤ k ≤ 10）\n\n输出格式每组输出一行，表示最多走 k 步后，马可以到达的不同位置数。\n输入样例23 0 0 18 0 0 2\n输出样例210\n解题思路\n使用 BFS 从起点出发，记录当前走了几步；\n只要当前步数 ≤ k，就尝试向 8 个马步方向扩展；\n使用 visited[x][y] 或 unordered_set 记录所有访问过的位置；\n最后统计不同位置的数量即可。\n\nC++ 参考代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 25;bool vis[MAXN][MAXN]; // 标记访问过的位置int n, k, count;int dx[8] = &#123;-2, -2, -1, -1, 1, 1, 2, 2&#125;;int dy[8] = &#123;-1, 1, -2, 2, -2, 2, -1, 1&#125;;void dfs(int x, int y, int step) &#123;    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n || step &lt; 0) return;    if (!vis[x][y]) &#123;        vis[x][y] = true;        count++;    &#125;    if (step == 0) return;    for (int i = 0; i &lt; 8; ++i) &#123;        int nx = x + dx[i];        int ny = y + dy[i];        dfs(nx, ny, step - 1);    &#125;&#125;int main() &#123;    int t;    cin &gt;&gt; t;    while (t--) &#123;        int x, y;        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; k;        count = 0;        memset(vis, 0, sizeof(vis));        dfs(x, y, k);        cout &lt;&lt; count &lt;&lt; endl;    &#125;    return 0;&#125;\n解码题目不记得了，反正超级长，没看懂\n月票的可能数","categories":["coding"],"tags":["computer","C/C++","algorithm"]},{"title":"MambaIRv2模型的测试与训练","url":"/2025/07/22/MambaIRv2%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%AE%AD%E7%BB%83/","content":"作为一个科研小白，对咱们来说非常重要的一项技能便是模型复现的入门到入土（接下来我们以CVPR2025年的一个工作–MambaIRv2为例，学习如何复现一篇论文  \n\n\nstep1 阅读论文，理解原理理论是要走在实践前面的（起码论文复现要先看懂论文）MambaIR是ECCV2024的一篇工作，将Mamba应用到了图像修复领域  \nMambaIRv2是它的二代，解决了扫描时的强制因果，加入了注意力机制，但又避免了复杂的计算MambaIRv2: Attentive State Space Restoration具体细节这里不过多阐述，需要自己去看论文\nstep2 测试我用的是autoDL上的V100进行测试，应该是完全足够的注意 PyTorch ≥ 2.0，cuda ≥ 11.7\n\n先进入到你想放的文件夹（不需要先创建一个MambaIR，因为git clone的时候会自行创建）  \n克隆github上的代码，并了解项目结构\n\ngit clone https://github.com/csguoh/MambaIR.git\n\n\n准备环境\n\ncd MambaIRconda env create -f environment.yamlconda activate mambair\n\n这一步需要很久环境安装一般不会一帆风顺，但是求助AI大概率可以解决\n\n准备数据集我只测试SR，那么就只需要下载SR的数据并保存到对应路径下数据在 https://github.com/csguoh/MambaIR.git 上有，下载好压缩包并放到datasets文件下，解压  \n准备模型权重文件（未训练直接测试）在 https://github.com/csguoh/MambaIR/releases 下寻找合适的权重文件，放到experiments下的pretrained里，也可以通过命令：\n\nwegt https://github.com/csguoh/MambaIR/releases/&lt;file name&gt;\n"},{"title":"Hello World","url":"/2025/04/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d \n$ hexo s\n\nCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"welcome！This is wendyLuo","url":"/2025/04/11/welcome%EF%BC%81This-is-wendyLuo/","content":"Welcome to my Blog!"},{"title":"哪些子弹在后来正中了眉心-杂谈篇","url":"/2025/06/06/%E5%93%AA%E4%BA%9B%E5%AD%90%E5%BC%B9%E5%9C%A8%E5%90%8E%E6%9D%A5%E6%AD%A3%E4%B8%AD%E4%BA%86%E7%9C%89%E5%BF%83-%E6%9D%82%E8%B0%88%E7%AF%87/","content":"入学以来，许多学长姐提的建议在当时还不曾有什么感受，直到后来，突然在某一天里，子弹正中眉心。  \n所以在这里，分享给大家我在学计算机两年来的后知后觉。\n\n\n1. C&#x2F;C++篇\n“学好C++真的很重要”\n“vector数组虽然大一下不怎么考但是真的很好用”\n\n2. github篇\n“最大的代码托管平台❌” -&gt; “应有尽有”\n“用好git，你会爱上git” (从网页端转向终端的过程是每个计算机学子必须要经历的，但是你会爱上这种感觉的)\n\n","categories":["reflection"],"tags":["computer"]},{"title":"一些小tips","url":"/2025/06/06/%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/","content":"notion美观好用的笔记软件，而且可以非常方便地进行协作网页端、PC端、pad端、手机端 应有尽有，实时同步最底层的逻辑是markdown格式，简直就是计算机人天菜最近发现一个AI速记功能，可以录音转总结，真的太香了（每次开组会都记不住讲了什么）  \n","categories":["source"],"tags":["agent"]},{"title":"本地部署deepseek+百度搜索","url":"/2025/05/09/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2deepseek-%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2/","content":"完成本地部署deepseek、联网搜索，以及页面交互功能具体分为以下三步：使用Ollama部署本地deepseek使用requests和beautifulsoup实现爬取网络检索内容使用streamlit创建交互界面\n\nOllama部署本地deepseek\n下载Ollama  \n建议不要下载到C盘，在CMD窗口输入：OllamaSetup.exe &#x2F;DIR&#x3D;你自己的路径  \n在高级系统设置的环境变量，新建一个环境变量 OLLAMA_MODELS ：刚刚ollama的路径&#x2F;models  \n在用户变量中新建变量名为OLLAMA_MODELS，变量值为：刚刚ollama的路径&#x2F;models  \n然后打开Ollama官网搜索deepseek，选择你想要的模型版本对应的的指令，在cmd中输入然后等待安装即可(运行之前要将ollama打开)\n\n\n\nrequests和beautifulsoup实现爬取网络检索内容requests发送请求，beautifulsoup解析网页结构，最后保存输出\nimport requestsfrom bs4 import BeautifulSoupimport timeimport osimport randomimport json  # 新增JSON模块导入def baidu_search(keyword, page_num=3):  # 默认爬取 3 页    user_agents = [        &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&quot;,    ]    headers = &#123;        &quot;User-Agent&quot;: random.choice(user_agents),        &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;,    &#125;        results = []    added_links = set()  # 用于存储已添加结果的链接    for page in range(page_num):        pn = page * 10  # 计算 pn 参数的值        search_url = f&quot;https://www.baidu.com/s?wd=&#123;requests.utils.quote(keyword)&#125;&amp;pn=&#123;pn&#125;&quot;        print(search_url)        try:            response = requests.get(search_url, headers=headers, timeout=10)            response.raise_for_status()            print(f&quot;第 &#123;page+1&#125; 页请求成功，状态码：&#123;response.status_code&#125;&quot;)             response.encoding = response.apparent_encoding            soup = BeautifulSoup(response.text, &#x27;html.parser&#x27;)            # 定位搜索结果容器            containers = soup.find_all(&#x27;div&#x27;, class_=&#x27;c-container&#x27;)            for container in containers:                # 提取标题和链接                title_tag = container.find(&#x27;h3&#x27;, class_=&#x27;t&#x27;)                if not title_tag or not title_tag.a:                    continue                title = title_tag.get_text(strip=True)                link = title_tag.a[&#x27;href&#x27;]                # 检查链接是否已存在                if link in added_links:                    continue                # 提取摘要（兼容新旧版页面结构）                abstract = &quot;&quot;                abstract_tag = container.find(&#x27;div&#x27;, class_=&#x27;c-abstract&#x27;) or \\                               container.find(&#x27;div&#x27;, class_=&#x27;content-right_8Zs40&#x27;) or \\                               container.find(&#x27;span&#x27;, class_=&#x27;c-font-normal&#x27;) or \\                               container.find(&#x27;span&#x27;, class_=&#x27;content-right_2s-H4&#x27;) or \\                               container.find(&#x27;div&#x27;, class_=&#x27;c-span-last&#x27;) or \\                               container.find(&#x27;span&#x27;, class_=&#x27;content-right_1THTn&#x27;) or \\                               container.find(&#x27;div&#x27;, class_=&#x27;right-link_NlGkt&#x27;)                if abstract_tag:                    abstract = abstract_tag.get_text(strip=True).replace(&#x27;\\n&#x27;, &#x27; &#x27;)                results.append(&#123;                    &#x27;title&#x27;: title,                    #&#x27;link&#x27;: link,                    &#x27;abstract&#x27;: abstract if abstract else &quot;暂无摘要信息&quot;                &#125;)                added_links.add(link)  # 将链接添加到已添加集合中                if len(results) &gt;= 10 * page_num:  # 限制结果数量防止触发反爬                    break                time.sleep(random.uniform(1, 3))  # 每次请求后延迟 2 秒        except Exception as e:            print(f&quot;第 &#123;page + 1&#125; 页请求异常：&#123;str(e)&#125;&quot;)    return resultsdef save_results_to_file(results, keyword):  # 函数名可保留，功能改为保存JSON    filename = os.path.join(os.getcwd(), f&quot;&#123;keyword&#125;_search_results.json&quot;)  # 改为JSON扩展名    with open(filename, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:        # 使用json.dump保存数据，设置ensure_ascii=False保证中文正常显示，indent=2增加可读性        json.dump(&#123;            &quot;keyword&quot;: keyword,            &quot;total&quot;: len(results),            &quot;results&quot;: results        &#125;, f, ensure_ascii=False, indent=2)    print(f&quot;√ 搜索结果已保存至 &#123;filename&#125;&quot;)  # 提示信息同步修改# 测试功能if __name__ == &quot;__main__&quot;:    keyword = &quot;李白&quot;    search_results = baidu_search(keyword, page_num=10)  # 爬取 10 页    if search_results:        print(&quot;search success&quot;)        save_results_to_file(search_results, keyword)    else:        print(&quot;× 搜索结果获取失败，请检查网络或重试&quot;)\nstreamlit创建交互界面感觉streamlit创建的页面最好看，网上教程很多，我直接把我的放在下面\nimport streamlit as stfrom ollama import chatfrom search import baidu_searchimport re# 页面配置st.set_page_config(    page_title=&quot;DeepSeek Chat&quot;,    page_icon=&quot;🤖&quot;,    layout=&quot;wide&quot;,)# 自定义 CSS 美化st.markdown(    &quot;&quot;&quot;    &lt;style&gt;    /* 背景、字体 */    body &#123;        /* 这里可以设置背景渐变色，例如 */        background: linear-gradient(to bottom right, #f7f7f7, #e6e6e6);         font-family: &#x27;Helvetica Neue&#x27;, Helvetica, Arial, sans-serif;    &#125;   .stApp &#123;        color: #333333;    &#125;    /* 聊天气泡 */   .user-bubble,.assistant-bubble &#123;        padding: 12px 16px;        border-radius: 16px;        margin: 8px 0;        max-width: 70%;        line-height: 1.4;        /* 添加阴影效果 */        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);     &#125;   .user-bubble &#123;        background-color: #FFEBE8;        color: #C0392B;        margin-left: auto;        /* 调整用户气泡文字样式 */        font-size: 16px;         font-weight: 500;     &#125;   .assistant-bubble &#123;        background-color: #E8F6FF;        color: #2471A3;        margin-right: auto;        /* 调整助手气泡文字样式 */        font-size: 16px;         font-weight: 500;     &#125;    /* 输入区 */   .stTextInput&gt;div&gt;div&gt;input &#123;        border: 2px solid #F39C12!important;        border-radius: 8px;    &#125;   .stButton&gt;button &#123;        background-color: #F39C12;        color: white;        border-radius: 8px;    &#125;    /* 侧边栏 */   .css-1d391kg &#123;        background-color: #FFF7E6;    &#125;   .sidebar.stText &#123;        font-size: 16px;    &#125;    &lt;/style&gt;    &quot;&quot;&quot;,    unsafe_allow_html=True)# 侧边栏with st.sidebar:    st.title(&quot;🎈 设置&quot;)    model = st.selectbox(        &quot;选择模型:&quot;,        options=[&quot;deepseek-r1:1.5b&quot;,&quot;deepseek-r1:7b&quot;],        help=&quot;选择你想使用的模型版本&quot;    )    st.markdown(&quot;---&quot;)    st.markdown(&quot;**说明:** 这是一个可爱的聊天界面，用于与 DeepSeek 进行对话。&quot;)# 主界面标题st.title(&quot;🤗 欢迎来到 DeepSeek 聊天机器人&quot;)# 初始化消息历史if &#x27;messages&#x27; not in st.session_state:    st.session_state.messages = [        &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Hello! 我是 DeepSeek 聊天机器人，有什么可以帮您？&quot;&#125;    ]def clean_response(raw_resp):    # 1. 先拿到纯文本    if hasattr(raw_resp, &quot;message&quot;) and hasattr(raw_resp.message, &quot;content&quot;):        # Ollama/其他 SDK 风格        text = raw_resp.message.content    elif hasattr(raw_resp, &quot;content&quot;):        # 万一又是 .content        text = raw_resp.content    else:        # 兜底        text = str(raw_resp)    # 2. 去掉 &lt;think&gt;…&lt;/think&gt; 块    text = re.sub(r&quot;&lt;think&gt;.*?&lt;/think&gt;\\s*&quot;, &quot;&quot;, text, flags=re.S)    # 3. 去掉开头自我介绍段落    text = re.sub(r&quot;^(你好！.*?提供更好的服务！\\s*)&quot;, &quot;&quot;, text, flags=re.S)    return text.strip()for msg in st.session_state.messages:    with st.chat_message(msg[&quot;role&quot;]):        st.markdown(msg[&quot;content&quot;])# 用户输入if prompt := st.chat_input(&quot;有什么需要我帮助的吗？&quot;):    # 1. 展示并存储用户输入    with st.chat_message(&quot;user&quot;):        st.markdown(prompt)    st.session_state.messages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;)    # 2. 在百度上检索    print(prompt)    search_results = baidu_search(prompt, page_num=3)    search_context = &quot;根据检索到的信息：\\n&quot;    for idx, item in enumerate(search_results, start=1):        search_context += (            f&quot;&#123;idx&#125;. 标题：&#123;item[&#x27;标题&#x27;]&#125;\\n&quot;            f&quot;   摘要：&#123;item[&#x27;摘要&#x27;]&#125;\\n&quot;        )    # 3. 把检索结果作为 system 消息插入到 user prompt 之前    insert_idx = len(st.session_state.messages) - 1    st.session_state.messages.insert(        insert_idx,        &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: search_context&#125;    )    # 4. 准备防“think”和自我介绍”的 system 指令    system_msg = &#123;        &quot;role&quot;: &quot;system&quot;,        &quot;content&quot;: (            &quot;你是一个直接回答问题的助手：\\n&quot;            &quot;- 不要输出任何 `&lt;think&gt;` 标签或内部思考。\\n&quot;            &quot;- 不要做自我介绍或额外寒暄。\\n&quot;            &quot;只需给出简洁、准确的回答。&quot;        )    &#125;    # 5. 调用大模型，并清洗、展示结果    with st.chat_message(&quot;assistant&quot;):        raw_response = chat(            model,            messages=[system_msg] + st.session_state.messages        )        cleaned = clean_response(raw_response)        st.markdown(cleaned)    # 6. 把清洗后的回复存入历史    st.session_state.messages.append(&#123;        &quot;role&quot;: &quot;assistant&quot;,        &quot;content&quot;: cleaned    &#125;)\n\n\n\n\n","categories":["project"],"tags":["computer","python"]},{"title":"计算机小白入门指南—工具资源篇","url":"/2025/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E2%80%94%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%E7%AF%87/","content":"🎯  愿景和目标希望每个迷茫的计算机小白都能得到一点帮助\n⛳️  知识空间简介计算机小白从0入门的各类帮助教程和工具\n💡  知识空间帮助欢迎大家补充说明，共同进步\n\n\n科学上网[计算机人第一步] (https://github.com/QiYongchuan/MyGitBlog/issues/54)\n常用工具[ai工具集] (https://ai-bot.cn/#term-2)豆包deepseekeasychatgrokchatGPT国内镜像网站：（需要翻）chat8（国内的，不需要翻）\n资源免费软件下载（微信公众号：悟空软件管家）免费获取电子版书籍（zlibrary： 需要翻墙）稀土掘金GitCode - 全球开发者的开源社区,开源代码托管平台吴川斌 CS自学指南CS基础知识保研攻略Google出品的一个自学AI网站谷歌学术对科研有帮助的\n学习资源基础课程微积分（b站：宋浩）线代（b站：梨米特）C++突击：BV1ZT4y1C7WR（讲的很好但是视频不全，只到继承和多态，慕课上有完整版但是要money）动画讲解算法：b站 蓝不过海啊（这个真的强推，很直观）  \n编程刷题很多厦大课程会用到的比如PTA、xmuoj 等等，其他还有一些例如leetcode、acwing等等CSDN，githubAcwing上的课(让我看看有多少人跟我一样买了看不完的)知乎上的leetcode算法刷题顺序：https://zhuanlan.zhihu.com/p/407414826?utm_psn=1792471197465849858\n进阶计算机科学速成课（很有意思，很适合小白）机器学习：李宏毅pytorch教程\n厦大资源：厦大邮箱（每个人开学的时候就注册好了，首次登入需要进行密码重置）厦大信息与网络中心（可以下载一些正版的软件）厦大云盘（上面有很多软件的安装包）厦大VPN（可以登录知网等）  \n一些小小杂谈\n   大学之处还是可以多去尝试，在尝试的过程中慢慢找到自己舒适的生活学习状态  \n   尽量早的去考虑自己将来想走什么样的路（保研？考研？工作？出国？），有选择性地努力，人不能既要又要，总要有取舍  \n   也别太功利，很多看似对学习没意义的事情才是人生的意义  \n   对于学生会社团等各种组织，辩证看待，不舒服就离开  \n   比赛先去参加，不是等自己100%准备好了才开始，都是边学边做  \n   找找志同道合的好朋友\n\n","categories":["source"],"tags":["computer","agent"]}]